use core::ops::Add;
use odra::casper_types::Key;
use odra::casper_types::U256;
use odra::prelude::*;
use odra::{casper_types::U512, Address, Event, Mapping, OdraError, Var};

pub type Meta = BTreeMap<String, String>;
pub type TokenId = U256;

#[derive(OdraError)]
pub enum Error {
    WrongArguments = 1,
    TokenIdAlreadyExists = 2,
}

#[derive(Event, PartialEq, Eq, Debug)]
pub struct Mint {
    pub recipient: Address,
    pub token_ids: Vec<TokenId>,
}

#[odra::module(events = [Mint])]
pub struct Cep47 {
    pub name: Var<String>,
    pub symbol: Var<String>,
    pub meta: Mapping<String, String>,
    pub total_supply: Var<U256>,
    pub balances: Mapping<Address, U256>,
    pub token_owner: Mapping<U256, Address>,
    pub token_meta: Mapping<U256, Meta>,
}

#[odra::module]
impl Cep47 {
    pub fn init(&mut self) {
        self.name.set(String::from("cep47_name"));
        self.symbol.set(String::from("cep47_symbol"));
        self.meta
            .set(&String::from("meta_key"), String::from("meta_value"));
    }

    pub fn name(&self) -> String {
        self.name.get_or_default()
    }
    pub fn symbol(&self) -> String {
        self.symbol.get_or_default()
    }
    pub fn meta(&self) {}
    pub fn total_supply(&self) -> U256 {
        self.total_supply.get_or_default()
    }
    pub fn balance_of(&self, owner: Address) -> U256 {
        self.balances.get_or_default(&owner)
    }
    pub fn owner_of(&self, token_id: TokenId) -> Option<Address> {
        self.token_owner.get(&token_id)
    }
    pub fn token_meta(&self, token_id: TokenId) -> Option<Meta> {
        self.token_meta.get(&token_id)
    }
    pub fn update_token_meta(&mut self, token_id: TokenId, meta: Meta) {
        self.token_meta.set(&token_id, meta);
    }
    pub fn mint(&mut self, recipient: Address, token_ids: Vec<TokenId>, token_metas: Vec<Meta>) {
        if token_ids.len() != token_metas.len() {
            self.env().revert(Error::WrongArguments)
        }

        for token_id in &token_ids {
            if self.owner_of(*token_id).is_some() {
                self.env().revert(Error::TokenIdAlreadyExists)
            }
        }

        for (token_id, token_meta) in token_ids.iter().zip(&token_metas) {
            self.token_meta.set(token_id, token_meta.clone());
            self.token_owner.set(token_id, recipient);
        }

        let minted_tokens_count: U256 = From::<u64>::from(token_ids.len().try_into().unwrap());
        self.balances.add(&recipient, minted_tokens_count);
        self.total_supply.add(minted_tokens_count);

        self.env().emit_event(Mint {
            recipient,
            token_ids,
        })
    }
    pub fn mint_copies(&self) {}
    pub fn burn(&self) {}
    pub fn transfer(&self) {}
    pub fn transfer_from(&self) {}
    pub fn approve(&self) {}
    pub fn get_approved(&self) {}
    pub fn get_token_by_index(&self) {}
}

// #[cfg(test)]
// mod tests {
//     use crate::flipper::FlipperHostRef;
//     use odra::host::{Deployer, NoArgs};

//     #[test]
//     fn flipping() {
//         let env = odra_test::env();
//         // To test a module we need to deploy it. Autogenerated `FlipperHostRef`
//         // implements `Deployer` trait, so we can use it to deploy the module.
//         let mut contract = FlipperHostRef::deploy(&env, NoArgs);
//         assert!(!contract.get());
//         contract.flip();
//         assert!(contract.get());
//     }
// }
